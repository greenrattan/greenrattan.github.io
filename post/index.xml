<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on greenrattan</title>
    <link>https://greenrattan.github.io/post/</link>
    <description>Recent content in Posts on greenrattan</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 10 Jul 2021 18:28:44 +0800</lastBuildDate><atom:link href="https://greenrattan.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Blog</title>
      <link>https://greenrattan.github.io/post/blog/</link>
      <pubDate>Sat, 10 Jul 2021 18:28:44 +0800</pubDate>
      
      <guid>https://greenrattan.github.io/post/blog/</guid>
      <description>博客的第二次建立。7.10
目的：对博客进行优化
.</description>
    </item>
    
    <item>
      <title>查找</title>
      <link>https://greenrattan.github.io/post/%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Mon, 31 May 2021 14:35:32 +0800</pubDate>
      
      <guid>https://greenrattan.github.io/post/%E6%9F%A5%E6%89%BE/</guid>
      <description>查找算法分类：
　1）静态查找和动态查找；
　注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。
　2）无序查找和有序查找。
　无序查找：被查找数列有序无序均可；
　有序查找：被查找数列必须为有序数列。
　**平均查找长度（Average Search Length，ASL）：**需和指定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。
　对于含有n个数据元素的查找表，查找成功的平均查找长度为：ASL = P i*C i的和。 P i：查找表中第i个数据元素的概率。 C i：找到第i个数据元素时已经比较过的次数。
有序表的折半查找基本思想：（2021/6/8）
在有序表中，取中间元素作为比较对象，若给定值与中间元素的关键码相等，则查找成功；若给定值小于中间元素的关键码，则在中间元素的左半区继续查找；若给定值大于中间元素的关键码，则在中间元素的右半区继续查找。不断重复上述查找过程，直到查找成功，或所查找的区域无数据元素，查找失败。
【步骤】 ① low=1；high=length； // 设置初始区间
② 当low&amp;gt;high 时，返回查找失败信息// 表空，查找失败 ③ low≤high，mid=(low+high)/2; //确定该区间的中点位置
​ a. 若kx&amp;lt;tbl.elem[mid].key，high = mid-1；转② // 查找在左半区进行
​ b. 若kx&amp;gt;tbl.elem[mid].key，low = mid+1； 转② // 查找在右半区进行
​ c. 若kx=tbl.elem[mid].key，返回数据元素在表中位置// 查找成功
有序表按关键码排列如下：
7，14，18，21，23，29，31，35，38，42，46，49，52
示例：
{ int mid,low,high, flag = 0; low = 0; high = length; /* ①设置初始区间* / while(low &amp;lt;= high) /* ②表空测试*/ { /* 非空,进行比较测试*/ mid = (low + high)/2; /* ③得到中点*/ if(kx &amp;lt; a[mid]) high = mid-1; /* 调整到左半区*/ else if(kx &amp;gt; a[mid]) low = mid+1; /* 调整到右半区*/ else { /* 查找成功,元素位置设置到flag 中*/ flag=mid; break; } } return flag; } 重要 常用的排序算法的时间复杂度和空间复杂度</description>
    </item>
    
  </channel>
</rss>
